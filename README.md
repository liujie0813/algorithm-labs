## leetcode

重点：
- program：纯编程类
- array：数组
- linkedlist：链表
- stask_queue：栈、队列
- recursion：递归
- sort：排序
- binary_search：二分查找
- hashtable：哈希表
- string：字符串
- tree：树
- bst：二分搜索树
- bfs&dfs：宽度&深度
- dp：动态规划
- 回溯

题型：
- 单调栈
- 双指针、滑动窗口
- 前缀后缀统计
- 位运算
- 海量数据处理

其他：
- 字符串匹配
- 图相关算法
- 跳表
- 并查集
- Trie
- 贪心


## 数组

**二分查找**

注意区间的定义：
- 左闭右闭 [left, right]
- 左闭右开 [left, right)

**双指针法**

通过快慢指针在一个 for 循环内完成两个循环的工作

**滑动窗口**

根据当前子序列和大小的情况，不断调节子序列的起始位置。

**模拟行为**

注意边界情况。

## 字符串

**双指针法**

反转单个字符串，使用双指针，一个指针从前往后，另一个指针从后往前。

反转字符串里的单词、左旋转字符串，主要思路就是先整体反转，再局部反转。

**KMP**

## 回溯

回溯的本质是穷举。可能有剪枝。

- 组合问题：77、17、39、40、216
- 切割问题：131、93
- 子集问题：78、90
- 排列问题：46、47
- 棋盘问题：N皇后 51、数独 37

组合问题和切割问题都是收集树的叶子节点，而子集问题是收集树的所有节点（一般不需要剪枝）

排列问题的不同：
- 每层是从 0 开始遍历，而不是 startIndex；
- 需要 used 数组记录 path 里都存放了哪些元素；

模板：

```
void backtracking(参数) {
	if (终止条件) {
	    存放结果
	    return;
	}
	for (选择: 本层集合中元素(树中节点孩子的数量就是集合大小) ) {
	    处理节点
	    backtracking(路径, 选择列表); // 递归
	    回溯，撤销处理结果    
	}
}
```

## 贪心

贪心的本质是选择每个阶段的最优解，从而达到全局最优。

如何验证可不可以用贪心？最好的策略就是举反例，如果想不到，就可以尝试一下贪心。

- 简单：455、1005、860
- 中等：
  - 序列问题：376、738
  - 股票问题：122、714
  - 两个维度权衡：135、406
    - 两个维度相互影响时，一般都要先确定一个维度，再考虑另一个维度
- 困难：
  - 区间：55、45、452、435、763、56
    - 区间问题一般都要排序（扫描线）；再考虑覆盖、去重等；
  - 53、134、968

## DP

### 理论基础

贪心是局部选取最优解；动态规划是每个状态由前一个状态推导出来的。

五步曲：
- 确定 dp 数组及下标的含义
- 确定递推公式
- dp 数组如何初始化
- 确定遍历顺序
- 举例推导 dp 数组

如何 debug？把 dp 数组打印出来，看是否是按照自己的思路推导的。

### 基础题目

- 斐波那契：509、70、746
- 整数拆分：343
- 不同的二分搜索树：96

### 背包问题

背包问题：
- 背包：最大容量 v
- 物品：
  - 价值 w
  - 体积 v
  - 每个物品的数量

根据每个物品的数量又分为：
- 01 背包：每个物品只有一个
- 完全背包：每个物品有无数个
- 多重背包：不同的物品数量不同

#### 01 背包

**普通解法**

定义：dp[i][j]，考虑前 i 个物品 [0, i]，放到容量为 j 的背包里，最大价值

推导，有两个方向：
- 不放物品 i：dp[i - 1][j]
- 放物品 i：dp[i - 1][j - weight[i]] + value[i]

状态转移方程：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weigh[i]] + value[i])

初始化：
- dp[i][0]：容量为 0 时，最大价值一定为 0；
- dp[0][j]：考虑第 0 个物品，如果 weight[0] 小于等于 capacity，则最大价值为 value[0]；

```java
public static int maxValue(int capacity, int[] weight, int[] value) {
    int n = weight.length;
    int[][] dp = new int[n][capacity + 1];
    for (int j = weight[0]; j <= capacity; j++) {
        dp[0][j] = value[0];
    }
    // 遍历物品
    for (int i = 1; i < n; i++) {
        // 遍历背包容量
        for (int j = 0; j <= capacity; j++) {
            if (j < weight[i]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
    return dp[n-1][capacity];
}
```

**滚动数组，空间优化**

滚动数组：上一层的结果可以重复利用，直接拷贝到当前层。

dp[j]：表示容量为 j 的背包，物品的最大价值和

推导：
- 不放物品 i：dp[j]，相当于二维数组中的 dp[i-1][j]
- 放物品 i：dp[j - weight[i]] + value[i]

状态转移方程：dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])

初始化：
- dp[0] = 0：背包容量为 0 时，最大价值一定为 0；
- dp[i]：由于 dp 数组在推导时都是取最大值，初始化为 0 就好

遍历顺序：
- 一维 dp 遍历时，背包容量是从大到小

dp[j] 由 dp[j - weight[i]] 推导而来：
- 如果使用正序遍历，在计算 dp[j] 时，dp[j - weight[i]] 已经被本层的结果覆盖了。对应到二维数组，就是取的是本层 dp[i][j-weight[i]] 的结果，但实际上应该取 dp[i-1][j-weight[i]]。 
- 但如果使用倒序遍历，在计算 dp[j] 时，dp[j - weight[i]] 还是上一层的结果，还未被覆盖

```java
public static int maxValue1(int capacity, int[] weight, int[] value) {
    int n = weight.length;
    int[] dp = new int[capacity + 1];
    // 遍历物品
    for (int i = 0; i < n; i++) {
        // 需要倒序遍历
        for (int j = capacity; j >= weight[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    return dp[capacity];
}
```

**完全背包**



**多重背包**

### 路径问题

- 不同路径：62、63

### 股票问题

### 子序列问题

### 打家劫舍